<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pac-Man HTML5</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #f7f7f7;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 20px;
      box-sizing: border-box;
    }
    h1 {
      margin: 0 0 10px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      text-shadow: 0 0 15px rgba(255, 255, 0, 0.4);
    }
    #ui {
      display: flex;
      gap: 1.5rem;
      align-items: center;
      margin-bottom: 8px;
      font-size: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #ui span.value {
      font-weight: 600;
      min-width: 40px;
      display: inline-block;
      text-align: right;
    }
    #ui .hint {
      opacity: 0.8;
      font-size: 13px;
    }
    #game {
      background: #000;
      border-radius: 8px;
      box-shadow: 0 0 24px rgba(0,0,0,0.9);
      image-rendering: pixelated;
    }
    #message {
      margin-top: 10px;
      min-height: 22px;
      font-size: 15px;
      text-align: center;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #ffd54a;
      text-shadow: 0 0 10px rgba(255, 213, 74, 0.5);
    }
  </style>
</head>
<body>
  <h1>Pac‑Man</h1>
  <div id="ui">
    <div>Score: <span class="value" id="score">0</span></div>
    <div>Lives: <span class="value" id="lives">3</span></div>
    <div>Level: <span class="value" id="level">1</span></div>
    <div class="hint">Arrow keys to move · Space to pause / restart</div>
  </div>
  <canvas id="game"></canvas>
  <div id="message"></div>

  <script>
    (function () {
      // --- Configuration ---
      const TILE_SIZE = 24;
      const LEVEL_TEMPLATE = [
        "###################",
        "#........#........#",
        "#.###.###.#.###.###",
        "#o# #.#.....#.# #o#",
        "#.###.#.###.#.###.#",
        "#.....#...#.#.....#",
        "#####.### # ###.###",
        "    #.#  G G  #.#  ",
        "#####.# ##=## #.###",
        "#........P........#",
        "###.###.###.###.###",
        "#...#.......#.....#",
        "#.#.#.#####.#.###.#",
        "#o..#...#...#....o#",
        "###.###.#.###.###.#",
        "#........#........#",
        "#.#######.#######.#",
        "#.................#",
        "#.###############.#",
        "#........#........#",
        "###################"
      ];

      const MAP_ROWS = LEVEL_TEMPLATE.length;
      const MAP_COLS = LEVEL_TEMPLATE[0].length;

      const PACMAN_SPEED = 90; // px/s
      const GHOST_SPEED = 75;
      const GHOST_FRIGHTENED_SPEED = 60;
      const FRIGHTENED_DURATION = 8; // seconds

      // --- Canvas & UI refs ---
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const livesEl = document.getElementById("lives");
      const levelEl = document.getElementById("level");
      const messageEl = document.getElementById("message");

      canvas.width = MAP_COLS * TILE_SIZE;
      canvas.height = MAP_ROWS * TILE_SIZE;

      // --- Game state ---
      let tiles = [];
      let pelletsRemaining = 0;
      let pacman = null;
      let ghosts = [];
      let ghostStartPositions = [];
      let pacmanStart = null;

      let score = 0;
      let lives = 3;
      let levelNumber = 1;
      let frightenedTimer = 0;
      let gameState = "playing"; // "playing" | "paused" | "gameover"
      let lastTime = 0;

      const ghostColors = ["#ff0000", "#ffb8ff", "#00ffff", "#ffb852"];

      // --- Helpers ---
      function updateScoreUI() {
        scoreEl.textContent = score.toString();
      }

      function updateLivesUI() {
        livesEl.textContent = lives.toString();
      }

      function updateLevelUI() {
        levelEl.textContent = levelNumber.toString();
      }

      function showMessage(text) {
        messageEl.textContent = text || "";
      }

      function clearMessage() {
        messageEl.textContent = "";
      }

      function getGridPosition(x, y) {
        return {
          col: Math.floor(x / TILE_SIZE),
          row: Math.floor(y / TILE_SIZE)
        };
      }

      function isBlocked(row, col, forGhost) {
        if (row < 0 || row >= MAP_ROWS || col < 0 || col >= MAP_COLS) {
          return true;
        }
        const tile = tiles[row][col];
        if (!tile) return true;
        if (tile.type === "wall") return true;
        if (tile.type === "door" && !forGhost) return true;
        return false;
      }

      function isBlockedAtPosition(x, y, forGhost, radius) {
        const left = x - radius;
        const right = x + radius;
        const top = y - radius;
        const bottom = y + radius;

        const points = [
          { x: left, y: top },
          { x: right, y: top },
          { x: left, y: bottom },
          { x: right, y: bottom }
        ];

        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          const col = Math.floor(p.x / TILE_SIZE);
          const row = Math.floor(p.y / TILE_SIZE);
          if (isBlocked(row, col, forGhost)) {
            return true;
          }
        }
        return false;
      }

      function canMove(entity, dx, dy, forGhost, step) {
        if (dx === 0 && dy === 0) return false;
        const nextX = entity.x + dx * step;
        const nextY = entity.y + dy * step;
        return !isBlockedAtPosition(nextX, nextY, forGhost, entity.radius);
      }

      function distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // --- Level setup ---
      function setupLevel() {
        tiles = [];
        pelletsRemaining = 0;
        pacmanStart = null;
        ghostStartPositions = [];
        ghosts = [];

        for (let row = 0; row < MAP_ROWS; row++) {
          tiles[row] = [];
          const line = LEVEL_TEMPLATE[row];
          for (let col = 0; col < MAP_COLS; col++) {
            const ch = line[col];
            let type = "empty";
            let pellet = false;
            let powerPellet = false;

            if (ch === "#") {
              type = "wall";
            } else if (ch === ".") {
              type = "empty";
              pellet = true;
              pelletsRemaining++;
            } else if (ch === "o") {
              type = "empty";
              powerPellet = true;
              pelletsRemaining++;
            } else if (ch === "=") {
              type = "door";
            } else if (ch === "P") {
              type = "empty";
              pacmanStart = { row, col };
            } else if (ch === "G") {
              type = "empty";
              ghostStartPositions.push({ row, col });
            } else {
              type = "empty";
            }

            tiles[row][col] = {
              type: type,
              pellet: pellet,
              powerPellet: powerPellet
            };
          }
        }

        if (!pacmanStart) {
          // Fallback to center if template is missing P
          pacmanStart = { row: Math.floor(MAP_ROWS / 2), col: Math.floor(MAP_COLS / 2) };
        }

        const startX = (pacmanStart.col + 0.5) * TILE_SIZE;
        const startY = (pacmanStart.row + 0.5) * TILE_SIZE;

        pacman = {
          x: startX,
          y: startY,
          radius: TILE_SIZE * 0.45,
          speed: PACMAN_SPEED,
          dx: 0,
          dy: 0,
          nextDx: 0,
          nextDy: 0
        };

        // Ensure at least 4 starting positions for ghosts
        if (ghostStartPositions.length === 0) {
          ghostStartPositions.push({ row: pacmanStart.row, col: pacmanStart.col });
        }
        while (ghostStartPositions.length < 4) {
          ghostStartPositions.push(ghostStartPositions[0]);
        }

        for (let i = 0; i < 4; i++) {
          const pos = ghostStartPositions[i];
          const gx = (pos.col + 0.5) * TILE_SIZE;
          const gy = (pos.row + 0.5) * TILE_SIZE;
          ghosts.push({
            x: gx,
            y: gy,
            radius: TILE_SIZE * 0.45,
            dx: 0,
            dy: 0,
            color: ghostColors[i % ghostColors.length],
            mode: "chase",
            startX: gx,
            startY: gy
          });
        }

        frightenedTimer = 0;
        clearMessage();
      }

      function resetPositions() {
        const startX = (pacmanStart.col + 0.5) * TILE_SIZE;
        const startY = (pacmanStart.row + 0.5) * TILE_SIZE;

        pacman.x = startX;
        pacman.y = startY;
        pacman.dx = 0;
        pacman.dy = 0;
        pacman.nextDx = 0;
        pacman.nextDy = 0;

        for (let i = 0; i < ghosts.length; i++) {
          const pos = ghostStartPositions[i % ghostStartPositions.length];
          const gx = (pos.col + 0.5) * TILE_SIZE;
          const gy = (pos.row + 0.5) * TILE_SIZE;
          const g = ghosts[i];
          g.x = gx;
          g.y = gy;
          g.dx = 0;
          g.dy = 0;
          g.mode = "chase";
        }

        frightenedTimer = 0;
      }

      function startNewGame() {
        score = 0;
        lives = 3;
        levelNumber = 1;
        updateScoreUI();
        updateLivesUI();
        updateLevelUI();
        setupLevel();
        gameState = "playing";
        clearMessage();
      }

      function levelComplete() {
        levelNumber += 1;
        updateLevelUI();
        showMessage("Level " + levelNumber);
        setupLevel();
      }

      // --- Pellet eating ---
      function eatPelletAtPosition(x, y) {
        const cell = getGridPosition(x, y);
        const row = cell.row;
        const col = cell.col;
        if (row < 0 || row >= MAP_ROWS || col < 0 || col >= MAP_COLS) {
          return;
        }
        const tile = tiles[row][col];
        if (!tile) return;

        if (tile.pellet) {
          tile.pellet = false;
          pelletsRemaining--;
          score += 10;
          updateScoreUI();
        } else if (tile.powerPellet) {
          tile.powerPellet = false;
          pelletsRemaining--;
          score += 50;
          updateScoreUI();
          frightenedTimer = FRIGHTENED_DURATION;
          for (let i = 0; i < ghosts.length; i++) {
            ghosts[i].mode = "frightened";
          }
        }

        if (pelletsRemaining === 0) {
          levelComplete();
        }
      }

      // --- Ghost AI ---
      function chooseGhostDirection(ghost, cell) {
        const directions = [
          { dx: 1, dy: 0 },
          { dx: -1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: 0, dy: -1 }
        ];

        const possible = [];
        for (let i = 0; i < directions.length; i++) {
          const d = directions[i];
          const nr = cell.row + d.dy;
          const nc = cell.col + d.dx;
          if (!isBlocked(nr, nc, true)) {
            possible.push(d);
          }
        }

        if (possible.length === 0) {
          // Nowhere to go; stop
          ghost.dx = 0;
          ghost.dy = 0;
          return;
        }

        // Avoid reversing direction when possible
        const reverseDx = -ghost.dx;
        const reverseDy = -ghost.dy;
        let filtered = possible.filter(function (d) {
          return !(d.dx === reverseDx && d.dy === reverseDy);
        });
        if (filtered.length === 0) {
          filtered = possible;
        }

        let chosen;
        if (ghost.mode === "frightened") {
          chosen = filtered[Math.floor(Math.random() * filtered.length)];
        } else {
          const pacCell = getGridPosition(pacman.x, pacman.y);
          let bestDist = Infinity;
          for (let i = 0; i < filtered.length; i++) {
            const d = filtered[i];
            const nr = cell.row + d.dy;
            const nc = cell.col + d.dx;
            const dx = pacCell.col - nc;
            const dy = pacCell.row - nr;
            const dist = dx * dx + dy * dy;
            if (dist < bestDist) {
              bestDist = dist;
              chosen = d;
            }
          }
        }

        ghost.dx = chosen.dx;
        ghost.dy = chosen.dy;
      }

      // --- Update functions ---
      function updatePacman(dt) {
        const step = pacman.speed * dt;
        if (step <= 0) return;

        const cell = getGridPosition(pacman.x, pacman.y);
        const centerX = (cell.col + 0.5) * TILE_SIZE;
        const centerY = (cell.row + 0.5) * TILE_SIZE;
        const distanceToCenter = Math.hypot(pacman.x - centerX, pacman.y - centerY);

        // Turn if there's a requested direction and we're near the center
        if ((pacman.nextDx !== 0 || pacman.nextDy !== 0) &&
          distanceToCenter < step * 1.1 &&
          !isBlocked(cell.row + pacman.nextDy, cell.col + pacman.nextDx, false)) {
          pacman.x = centerX;
          pacman.y = centerY;
          pacman.dx = pacman.nextDx;
          pacman.dy = pacman.nextDy;
          pacman.nextDx = 0;
          pacman.nextDy = 0;
        }

        if (pacman.dx !== 0 || pacman.dy !== 0) {
          if (canMove(pacman, pacman.dx, pacman.dy, false, step)) {
            pacman.x += pacman.dx * step;
            pacman.y += pacman.dy * step;
          } else if (distanceToCenter < step) {
            // Snap to center when hitting a wall
            pacman.x = centerX;
            pacman.y = centerY;
          }
        }

        eatPelletAtPosition(pacman.x, pacman.y);
      }

      function updateGhost(ghost, dt) {
        const speed = ghost.mode === "frightened" ? GHOST_FRIGHTENED_SPEED : GHOST_SPEED;
        const step = speed * dt;
        if (step <= 0) return;

        const cell = getGridPosition(ghost.x, ghost.y);
        const centerX = (cell.col + 0.5) * TILE_SIZE;
        const centerY = (cell.row + 0.5) * TILE_SIZE;
        const distanceToCenter = Math.hypot(ghost.x - centerX, ghost.y - centerY);

        if (distanceToCenter < step) {
          ghost.x = centerX;
          ghost.y = centerY;
          chooseGhostDirection(ghost, cell);
        }

        if (ghost.dx !== 0 || ghost.dy !== 0) {
          if (canMove(ghost, ghost.dx, ghost.dy, true, step)) {
            ghost.x += ghost.dx * step;
            ghost.y += ghost.dy * step;
          }
        }
      }

      function handlePacmanHit() {
        if (gameState !== "playing") return;
        lives -= 1;
        updateLivesUI();

        if (lives <= 0) {
          gameState = "gameover";
          showMessage("Game over – press Space to restart");
        } else {
          resetPositions();
        }
      }

      function update(dt) {
        if (gameState !== "playing") return;

        if (frightenedTimer > 0) {
          frightenedTimer -= dt;
          if (frightenedTimer <= 0) {
            frightenedTimer = 0;
            for (let i = 0; i < ghosts.length; i++) {
              if (ghosts[i].mode === "frightened") {
                ghosts[i].mode = "chase";
              }
            }
          }
        }

        updatePacman(dt);

        for (let i = 0; i < ghosts.length; i++) {
          updateGhost(ghosts[i], dt);
        }

        // Check collisions with ghosts
        for (let i = 0; i < ghosts.length; i++) {
          const g = ghosts[i];
          const distPG = distance(pacman, g);
          if (distPG < pacman.radius + g.radius - 2) {
            if (g.mode === "frightened") {
              // Eat ghost
              score += 200;
              updateScoreUI();
              g.x = g.startX;
              g.y = g.startY;
              g.dx = 0;
              g.dy = 0;
              g.mode = "chase";
            } else {
              handlePacmanHit();
              break;
            }
          }
        }
      }

      // --- Drawing functions ---
      function drawMap(timestamp) {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < MAP_ROWS; row++) {
          for (let col = 0; col < MAP_COLS; col++) {
            const tile = tiles[row][col];
            const x = col * TILE_SIZE;
            const y = row * TILE_SIZE;
            const centerX = x + TILE_SIZE / 2;
            const centerY = y + TILE_SIZE / 2;

            if (tile.type === "wall") {
              ctx.fillStyle = "#1919a6";
              ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
              ctx.strokeStyle = "#5b5bff";
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            } else if (tile.type === "door") {
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(x, y + TILE_SIZE / 2);
              ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE / 2);
              ctx.stroke();
            }

            if (tile.pellet) {
              ctx.fillStyle = "#ffb8ae";
              ctx.beginPath();
              ctx.arc(centerX, centerY, TILE_SIZE * 0.09, 0, Math.PI * 2);
              ctx.fill();
            } else if (tile.powerPellet) {
              const t = timestamp || performance.now();
              const pulse = 0.7 + 0.3 * Math.sin(t / 120);
              const radius = TILE_SIZE * 0.16 * pulse;
              ctx.fillStyle = "#ffffff";
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }

      function drawPacman(timestamp) {
        const t = timestamp || performance.now();
        const x = pacman.x;
        const y = pacman.y;
        const r = pacman.radius;
        const oscillation = 0.25 + 0.10 * Math.sin(t / 80);
        let startAngle, endAngle;

        if (pacman.dx === 1) { // right
          startAngle = oscillation;
          endAngle = -oscillation;
        } else if (pacman.dx === -1) { // left
          startAngle = Math.PI - oscillation;
          endAngle = Math.PI + oscillation;
        } else if (pacman.dy === -1) { // up
          startAngle = -Math.PI / 2 + oscillation;
          endAngle = -Math.PI / 2 - oscillation;
        } else if (pacman.dy === 1) { // down
          startAngle = Math.PI / 2 + oscillation;
          endAngle = Math.PI / 2 - oscillation;
        } else {
          startAngle = oscillation;
          endAngle = -oscillation;
        }

        ctx.fillStyle = "#ffed00";
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, r, startAngle, endAngle, false);
        ctx.closePath();
        ctx.fill();

        // Eye
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(x, y - r * 0.4, r * 0.12, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawGhost(ghost) {
        const x = ghost.x;
        const y = ghost.y;
        const r = ghost.radius;

        const bodyColor = ghost.mode === "frightened" ? "#2b9fff" : ghost.color;
        ctx.fillStyle = bodyColor;

        // Body
        ctx.beginPath();
        ctx.arc(x, y - r * 0.3, r, Math.PI, 0, false); // head
        ctx.lineTo(x + r, y + r);
        ctx.lineTo(x - r, y + r);
        ctx.closePath();
        ctx.fill();

        // Eyes
        ctx.fillStyle = "#ffffff";
        const eyeOffsetX = ghost.mode === "frightened" ? 0 : ghost.dx * r * 0.2;
        const eyeOffsetY = ghost.mode === "frightened" ? 0 : ghost.dy * r * 0.2;

        ctx.beginPath();
        ctx.arc(x - r * 0.4, y - r * 0.3, r * 0.3, 0, Math.PI * 2);
        ctx.arc(x + r * 0.4, y - r * 0.3, r * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Pupils
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(x - r * 0.4 + eyeOffsetX, y - r * 0.3 + eyeOffsetY, r * 0.12, 0, Math.PI * 2);
        ctx.arc(x + r * 0.4 + eyeOffsetX, y - r * 0.3 + eyeOffsetY, r * 0.12, 0, Math.PI * 2);
        ctx.fill();
      }

      function draw(timestamp) {
        drawMap(timestamp);

        // Draw ghosts first so Pac-Man is "on top"
        for (let i = 0; i < ghosts.length; i++) {
          drawGhost(ghosts[i]);
        }

        drawPacman(timestamp);

        if (gameState === "paused") {
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#ffd54a";
          ctx.font = "20px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
        } else if (gameState === "gameover") {
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#ff5252";
          ctx.font = "20px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
        }
      }

      // --- Input ---
      window.addEventListener("keydown", function (e) {
        const key = e.key;

        if (key === "ArrowLeft" || key === "Left") {
          if (!pacman) return;
          pacman.nextDx = -1;
          pacman.nextDy = 0;
          e.preventDefault();
        } else if (key === "ArrowRight" || key === "Right") {
          if (!pacman) return;
          pacman.nextDx = 1;
          pacman.nextDy = 0;
          e.preventDefault();
        } else if (key === "ArrowUp" || key === "Up") {
          if (!pacman) return;
          pacman.nextDx = 0;
          pacman.nextDy = -1;
          e.preventDefault();
        } else if (key === "ArrowDown" || key === "Down") {
          if (!pacman) return;
          pacman.nextDx = 0;
          pacman.nextDy = 1;
          e.preventDefault();
        } else if (key === " " || key === "Spacebar") {
          e.preventDefault();
          if (gameState === "gameover") {
            startNewGame();
          } else if (gameState === "playing") {
            gameState = "paused";
            showMessage("Paused – press Space to resume");
          } else if (gameState === "paused") {
            gameState = "playing";
            clearMessage();
          }
        }
      });

      // --- Main loop ---
      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        update(dt);
        draw(timestamp);
        requestAnimationFrame(loop);
      }

      // Initialize
      setupLevel();
      updateScoreUI();
      updateLivesUI();
      updateLevelUI();
      showMessage("Ready! Use arrow keys. Space pauses.");

      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
